"var f=Object.defineProperty;var R=(s,e,n)=>e in s?f(s,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[e]=n;var g=(s,e,n)=>(R(s,typeof e!=\"symbol\"?e+\"\":e,n),n);var b=(s,e)=>({value:s,transferables:e,__x_tdata__:1432234}),h=s=>typeof s==\"object\"&&s!==null&&\"__x_tdata__\"in s&&s?.__x_tdata__===1432234;var u=\"__x_rpc_error__\",T=\"__x_rpc_response__\",l=[],c=class{idCount;queue;actionsIndex;messageContainer;messageTarget;messageInterceptor;constructor({responses:e,messageTarget:n,messageInterceptor:t}){this.messageInterceptor=t,this.messageTarget=n,this.messageInterceptor.addEventListener(\"message\",a=>{r.consumeMessage(a.data,\"source\"in a&&a.source||null)});let r=this;this.idCount=0,this.queue=[],this.messageContainer={handle:\"\",id:-1,respondingTo:-1,data:null},this.actionsIndex=new Map;let o=Object.keys(e);for(let a=0;a<o.length;a++){let i=o[a];this.actionsIndex.set(i,e[i])}}async executeWithSource(e,n,t,r){return await this.outboundMessage(n,e,t,r)}async execute(e,n=null,t=l){return await this.outboundMessage(this.messageTarget,e,n,t)}outboundMessage(e,n,t=null,r=l){let o=this;return new Promise((a,i)=>{let p=this.idCount;o.queue.push({id:p,resolve:a,reject:i}),o.transferMessage(e,n,-1,t,r)})}responseMessage(e,n,t){let r=h(t);this.transferMessage(e,T,n,r?t.value:t,r?t.transferables:l)}errorResponseMessage(e,n,t){this.transferMessage(e,u,n,t)}transferMessage(e,n,t,r,o){let{messageContainer:a}=this,i=this.idCount++;return a.handle=n,a.respondingTo=t,a.data=r??null,a.id=i,(e||this.messageTarget).postMessage(a,o||l),a.data=null,i}async consumeMessage(e,n){if(e===null||typeof e!=\"object\"){console.warn(\"recieved message was not an object ignoring message\",e);return}if(e.handle===T||e.handle===u){let{queue:t}=this;for(let r=0;r<t.length;r++){let o=t[r];if(e.respondingTo===o.id){e.handle===u?o.reject(e.data):o.resolve(e.data),t.splice(r,1);return}}console.warn(\"incoming response doesn't map to any queued message. ignoring\",e);return}if(!this.actionsIndex.has(e.handle)){this.errorResponseMessage(n,e.id,`attempted to call non-existent handler \"${e.handle}\"`);return}if(e.respondingTo===-1){let t=this.actionsIndex.get(e.handle);try{let r=await t(e.data)??null;this.responseMessage(n,e.id,r)}catch(r){this.errorResponseMessage(n,e.id,`rpc function \"${e.handle}\" encountered an exception. ${r} ${r?.stack||\"no-stack\"}`)}return}console.warn(\"incoming message is neither a response to a previous message or a request to perform an action. ignoring message\",e)}};g(c,\"transfer\",b);var y=self,{parent:x}=y,A=new c({responses:{},messageTarget:{postMessage:(s,e)=>{x.postMessage(s,\"*\",e)}},messageInterceptor:{addEventListener:(s,e)=>{y.addEventListener(\"message\",e)}}}),m={getFile:async s=>{let e=await A.execute(\"getFile\",s);return e&&c.transfer(e,[e.body])}};if(window.top!==window.parent)throw new Error(\"second-level embedding is disallowed\");if(window.self===window.top)throw new Error(\"document must be embedded in iframe\");if(!(\"serviceWorker\"in navigator))throw new Error(\"sandbox requires service worker to function\");try{let[s]=await Promise.all([navigator.serviceWorker.ready,navigator.serviceWorker.register(\"sw.compiled.js\")]),{active:e}=s,n=new c({responses:m,messageTarget:{postMessage(p,d){e?.postMessage(p,d)}},messageInterceptor:{addEventListener(p,d){navigator.serviceWorker.addEventListener(\"message\",d)}}}),r=document.getElementById(\"root-script\")?.getAttribute(\"entry\")||\"none\";console.info(\"importing\",r);let o=await import(r);if(!(\"main\"in o))throw new Error(\"no main function exported from module\");let a=document.createElement(\"div\");a.setAttribute(\"id\",\"root\"),document.body.appendChild(a);let{main:i}=o;i({rootElement:a})}catch(s){console.error(\"error when loading module\",s)}\n"